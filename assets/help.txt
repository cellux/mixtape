Mixtape Help
============

Editor key bindings
-------------------
Evaluate / play:
- C-p: eval buffer and play result
- C-Enter: eval buffer (no playback)
- C-g / Esc: cancel current evaluation

Files:
- C-x C-s: save (only when GUI started with a file path)

Quit / undo:
- C-q: quit
- C-z / C-x u / C-S--: undo

Cursor movement:
- Arrow keys: move
- Home / End: line start/end
- C-a / C-e: line start/end
- C-Home / C-End: buffer start/end
- C-Left / C-Right or M-b / M-f: word left/right
- PageUp / PageDown: scroll screen

Editing:
- Type / Enter / Tab: insert / newline / indent (tab = 2 spaces)
- Backspace / Delete: delete before/at point
- C-k: kill to end of line (or join)

Region / clipboard:
- C-Space: set mark
- C-w: cut region
- M-w: copy region
- C-y: paste
- C-Backspace / M-Backspace: kill previous word
- C-u: kill to line start

DSL overview
------------
Language model: concatenative, stack-based. Tokens run left-to-right. Words consume stack values and push results (postfix calling).

Comments: `;` to end of line.

Types: Num (float/boolean), Nil, Str, Sym, Vec, Tape, Stream, Wavetable. Environment is a map (set/get). Streamable = Num | Vec of samples | Tape | Stream.

Stack comments: `word: ( inputs -- outputs )`; `ENV:` shows env vars read; `SETS:` env vars written.

Quoting and eval:
- `{ ... }` collects tokens into a quoted Vec (closure-like). It is data until run with `eval`.
- `eval` on a Vec runs its items in order. `eval` on other values usually just pushes them (numbers/strings/etc). Iterators are callable via `eval` to get next.

Vectors:
- `[` marks the stack; `]` collects everything pushed since the mark into a Vec (data literal built from runtime values).

Environments:
- `(` pushes a new env frame; `)` pops it. `set`/`get` read/write current frame.

Syntax sugar:
- `:name` → `":name" get` (fetch env var)
- `@foo` → `"foo" get`; `>foo` → `"foo" set`
- Time suffixes: `1s`→`1 seconds`, `1b`→`1 beats`, `1t`→`1 ticks`, `1p`→`1 periods`
- Ratios `1/4` and MIDI notes `c-4` etc parse to numbers.

Methods: some words dispatch on receiver type (e.g., `+`, `len`). Dispatch uses word name and arity.

Doc comments (from prelude)
---------------------------
BUILTINS

core
- nil: ( -- nil ) push Nil onto stack
- throw: ( x -- ) raise an exception carrying x
- catch: ( body -- x|nil ) evaluate body and capture value carried in exception (or nil on success)
- loop: ( body -- ) evaluate body repeatedly until break/throw
- stack: ( -- v ) push current stack snapshot
- log: ( x -- x ) log top of stack without consuming it
- str: ( x -- str ) stringify
- drop: ( x -- ) drop top
- nip: ( x y -- y ) drop second-from-top
- dup: ( x -- x x ) duplicate top
- swap: ( x y -- y x ) swap top two
- over: ( x y -- x y x ) copy second to top
- (: ( -- ) push new environment
- ): ( -- ) pop environment
- [: ( -- ) mark stack position
- ]: ( <xs> -- v ) collect items pushed since last stack mark, remove mark
- {: ( -- ) quote on
- }: ( -- v ) quote off
- set: ( x k -- ) set env var named by key
- get: ( k -- x ) fetch env var named by key
- eval: ( x -- <xs> ) evaluate x
- iter: ( I -- i ) obtain iterator from iterable
- next: ( i -- i x|nil ) advance iterator
- vdup: ( x n -- [xs] ) n copies of x in vec
- Num.if: ( b then -- ) conditional execute when nonzero
- Num.if: ( b then else -- ) conditional with else branch
- Num.<: ( n n -- b ) less-than
- Num.<=: ( n n -- b ) less-or-equal
- Num.>=: ( n n -- b ) greater-or-equal
- Num.>: ( n n -- b ) greater-than
- Vec.len: ( v -- n ) length of vector
- Vec.at: ( v k -- x ) indexed lookup
- Vec.clone: ( v -- v ) shallow copy
- Vec.push: ( v x -- v ) append item, mutates v
- Vec.pop: ( v -- v x ) pop last item, mutates v
- Vec.each: ( v body -- ) iterate and eval body per item
- Vec.map: ( v body -- v ) map body over items
- Vec.reduce: ( v body -- x ) fold left with body, returns nil if v is empty
- Vec.partition: ( v size step -- [vs] ) window vector
- Vec.tape: ( v -- t ) convert numeric vector to mono tape
- Str.+: ( str1 str2 -- str ) concatenate strings
- Str.load: ( str -- t ) load audio file
- Str.path/join: ( str1 str2 -- str ) join file system paths
- Str.parse: ( str -- v ) parse string into AST words
- Str.parse1: ( str -- x ) parse and take first word

math
- e: ( -- n ) Euler's constant
- pi: ( -- n ) pi constant
- abs: ( S -- s|n ) absolute value
- sign: ( S -- s|n ) sign of x (-1, 0, 1)
- square: (S -- s|n ) square (x = x^2)
- exp: ( S -- s|n ) natural exponential
- exp2: ( S -- s|n ) power-of-two exponential
- log10: ( S -- s|n ) base-10 logarithm
- log2: ( S -- s|n ) base-2 logarithm
- floor: ( S -- s|n ) floor
- ceil: ( S -- s|n ) ceiling
- trunc: ( S -- s|n ) truncate toward zero
- round: ( S -- s|n ) round to nearest integer
- sin: ( S -- s|n ) sine
- cos: ( S -- s|n ) cosine
- tan: ( S -- s|n ) tangent
- asin: ( S -- s|n ) arcsine
- acos: ( S -- s|n ) arccosine
- atan: ( S -- s|n ) arctangent
- sinh: ( S -- s|n ) hyperbolic sine
- cosh: ( S -- s|n ) hyperbolic cosine
- tanh: ( S -- s|n ) hyperbolic tangent
- asinh: ( S -- s|n ) inverse hyperbolic sine
- acosh: ( S -- s|n ) inverse hyperbolic cosine
- atanh: ( S -- s|n ) inverse hyperbolic tangent
- =: ( x y -- b ) equality check
- +: ( S S -- s|n ) add
- -: ( S S -- s|n ) subtract
- *: ( S S -- s|n ) multiply
- /: ( S S -- s|n ) divide
- mod: ( S S -- s|n ) modulus
- rem: ( S S -- s|n ) remainder
- pow: ( S S -- s|n ) power
- atan2: ( S S -- s|n ) arctangent with quadrant
- hypot: ( S S -- s|n ) hypotenuse length
- min: ( S S -- s|n ) minimum
- max: ( S S -- s|n ) maximum
- clamp: ( S min max -- s|n ) clamp samples to range

random numbers
- rand: ( -- n ) random float in [0,1)
- rand/seed: ( n -- ) reseed RNG used by rand

envelope segments
- /line: ( ENV: :start :end :nf | -- t ) linear envelope segment
- /exp: ( ENV: :start :end :nf | k -- t ) exponential envelope segment with curve k
- /log: ( ENV: :start :end :nf | k -- t ) logarithmic envelope segment with curve k
- /cos: ( ENV: :start :end :nf | -- t ) cosine ease-in/out envelope segment
- /pow: ( ENV: :start :end :nf | p -- t ) power-law envelope segment with exponent p
- /sigmoid: ( ENV: :start :end :nf | k -- t ) logistic envelope segment with slope k

tapes
- tape1: ( n -- t ) allocate mono tape
- tape2: ( n -- t ) allocate stereo tape
- tape/sin: ( n -- t ) sine wave (single-cycle)
- tape/tanh: ( n -- t ) tanh-shaped wave (single-cycle)
- tape/triangle: ( n -- t ) triangle wave (single-cycle)
- tape/square: ( n -- t ) square wave (single-cycle)
- tape/pulse: ( ENV: :pw | n -- t ) pulse wave using env pulse width (single-cycle)
- tape/saw: ( n -- t ) saw wave (single-cycle)
- Tape.shift: ( t amount -- t ) rotate samples by amount, mutates t
- Tape.resample: ( t converter ratio -- t ) resample tape
- Tape.at: ( t frame -- n|[ns] ) fetch frame
- Tape.slice: ( t start end -- t ) tape with frames of t between [start,end)
- Tape.+@: ( t t2 offset -- t ) mix t2 into t at offset, mutates t

stream generators
- ~: ( S -- s ) coerce to stream
- ~empty: ( n -- s ) empty stream of n channels
- ~impulse: ( ENV: :freq :phase | -- s ) band-limited impulse train
- ~phasor: ( ENV: :freq :phase | -- s ) phase-accumulating oscillator with output in range [0,1(

stream transformers
- dc*: ( S alpha -- s ) DC-blocking IIR with smoothing alpha
- onepole: ( S alpha -- s ) first-order IIR smoother; higher alpha = more smoothing
- lp1: ( ENV: :cutoff | S -- s ) first-order lowpass, cutoff in Hz
- hp1: ( ENV: :cutoff | S -- s ) first-order highpass, cutoff in Hz
- ap1: ( ENV: :cutoff | S -- s ) first-order allpass, phase rotate around cutoff Hz
- ap2: ( ENV: :cutoff :q | S -- s ) second-order biquad allpass, phase rotate with controllable Q
- ls2: ( ENV: :cutoff :q :gain | S -- s ) 2-pole low-shelf (TPT SVF + gain)
- hs2: ( ENV: :cutoff :q :gain | S -- s ) 2-pole high-shelf (TPT SVF + gain)
- svf: ( ENV: :cutoff :q :blend | S -- s ) state-variable filter
- notch2: ( ENV: :cutoff :q | S -- s ) 2-pole notch (derived from SVF core)
- peak2: ( ENV: :cutoff :q :gain | S -- s ) 2-pole peaking/bell EQ (SVF-derived)
- peak: ( S -- s ) max(abs(x) for x in frame)
- sh: ( S rate -- s ) sample-and-hold input at rate
- comb: ( S delay fb -- s ) feedback comb filter
- delay: ( S n -- s ) delay by n frames
- z1*: ( S n|[ns] -- s ) one-sample delay with explicit init frame (Num or Vec of per-channel smps)
- pan: ( S pan -- s ) equal-power pan mono input with pan between [-1,1]
- mix: ( [Ss] ratio -- s ) mix streams based on ratio clamped to [0,1]
- softclip: ( S mode -- s ) smooth saturation (0=tanh, 1=atan, 2=poly, 3=softsign)
- skip: ( S n -- s ) skip first n frames
- unison: ( ENV: :freq :voices :spread :detune :phaseRand | body -- s ) detuned/positioned voices
- mono: ( S -- s ) sum/convert to mono
- stereo: ( S -- s ) ensure stereo

stream renderers
- frames: ( s -- [ns|[ns]] ) collect all frames into vec, s must be finite
- take: ( s n -- t ) take first n frames

stream utilities
- Streamable.join: ( S S -- s ) concatenate streams
- Streamable.len ( S -- n ) length of stream, or 0 if stream is infinite

noise generators
- ~noise: ( ENV: :seed | -- s ) white noise
- ~pink: ( ENV: :seed | -- s ) pink noise
- ~brown: ( ENV: :seed | step -- s ) brown noise with step size

waves and wavetables
- wt: ( x -- wt ) coerce to wavetable
- ~wt: ( ENV: :freq :phase :morph | wt -- s ) wavetable oscillator with env freq/phase/morph
- ~fm: ( ENV: :freq :mod :index :phase | wt -- s ) wavetable FM oscillator with env controls

misc
- sr: ( -- n ) push global sample rate

STANDARD LIBRARY

booleans / control
- true: ( -- -1 )
- false: ( -- 0 )
- false?: ( x -- b )
- not: ( x -- b )
- !=: ( x y -- b )
- true?: ( x -- b )
- nil?: ( x -- b )
- assert: ( body -- ) evaluates body and throws error if result is false
- break: ( -- ) exits current loop

oscillator parameters
- :freq: ( -- n ) frequency
- :phase: ( -- n ) phase
- :pw: ( -- n ) pulse width
- f: ( n -- | SETS: :freq ) shorthand for setting :freq to n

filter parameters
- :cutoff: ( -- n ) cutoff
- :q: ( -- n ) resonance
- :blend: ( -- n ) blend
- :gain: ( -- n ) linear gain multiplier

FM parameters
- :mod: ( -- n ) FM phase offset (in cycles)
- :index: ( -- n ) FM index

noise RNG parameters
- :seed: ( -- n ) seed used by noise generators

envelope parameters
- start: ( -- n )
- end: ( -- n )

utilities
- sum: ( [Ss|ns] -- s|n )
- distribute: ( [ns] n -- [ns] ) scale vals so their sum equals n; sum(ns) must be nonzero
- avg: ( [Ss|ns] -- s|n ) average a list of streams/numbers
- clip: ( S -- s ) constrain stream samples to [-1,1]
- cat: ( [Ss] -- s ) concatenate streams
- repeat: ( S n -- s ) repeat and concat
- start:end: ( [ns] -- | SETS: :start :end )
- for: ( I body -- <xs> ) evaluates body for each value produced by I
- zip: ( [xs] -- [[ys]] ) pull in lockstep until any iterator yields nil

sequencer
- seq: ( body [syms] -- <xs> ) see examples/seq.tape for details

time
- seconds: ( dur -- n ) length of n seconds in frames
- beats: ( :bpm beats -- n ) length of n beats in frames
- periods: ( ENV: :freq | periods -- n ) length of n periods in frames
- ticks: ( ENV: :bpm :tpb | ticks -- n ) length of n ticks in frames

pitch
- st: ( semitones -- ratio ) frequency multiplier for n semitone steps
- mtof: ( midi-note -- freq ) frequency for MIDI note n
- cents: ( cents -- ratio ) frequency multiplier for n cents

amplitude
- db: ( db -- amp ) convert decibels to linear amplitude multiplier
- gain: ( S db -- s ) apply gain in dB to a stream

unipolar <-> bipolar
- uni: ( bipolar -- unipolar )
- bi: ( unipolar -- bipolar )

envelope generators
- env: ( [ys] [ds] [segs] -- env )
- adsr: ( a d s r dur -- env )
- perc: ( a r -- env )

oscillators
- ~sin: ( ENV: :freq :phase | -- s )
- ~tanh: ( ENV: :freq :phase | -- s )
- ~triangle: ( ENV: :freq :phase | -- s )
- ~square: ( ENV: :freq :phase | -- s )
- ~pulse: ( ENV: :freq :phase :pw | -- s )
- ~saw: ( ENV: :freq :phase | -- s )
- wt/sin: ( -- wt ) sine wavetable
- wt/tanh: ( -- wt ) tanh wavetable
- wt/triangle: ( -- wt ) triangle wavetable
- wt/square: ( -- wt ) square wavetable
- wt/pulse: ( -- wt ) pulse wavetable
- wt/saw: ( -- wt ) saw wavetable

dsp
- dc: ( S -- s ) remove DC offset with alpha = 1-1/SR
- z1: ( s -- s ) one-sample delay with zero init
- stretch: ( S factor -- s )

filters
- lp2: ( ENV: :cutoff :q | S -- s ) 2-pole lowpass (TPT SVF)
- bp2: ( ENV: :cutoff :q | S -- s ) 2-pole bandpass (TPT SVF)
- hp2: ( ENV: :cutoff :q | S -- s ) 2-pole highpass (TPT SVF)
- lp4: ( ENV: :cutoff :q | S -- s ) 4-pole lowpass (TPT SVF)
- bp4: ( ENV: :cutoff :q | S -- s ) 4-pole bandpass (TPT SVF)
- hp4: ( ENV: :cutoff :q | S -- s ) 4-pole highpass (TPT SVF)
- ap4: ( ENV: :cutoff :q | S -- s ) 4-pole allpass (TPT SVF)
- notch4: ( ENV: :cutoff :q | S -- s ) 4-pole notch (TPT SVF)
- peak4: ( ENV: :cutoff :q :gain | S -- s ) 4-pole peak (TPT SVF)
